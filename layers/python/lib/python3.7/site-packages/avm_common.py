import os
import boto3
import json

from botocore.exceptions import ClientError

def get_account_details(accountId):
    """
    Retrieve both the organization details and the account request information
    for a given vended AWS account ID.
    """
    session = boto3.Session()
    current_region = os.getenv('AWS_REGION')
    resource = session.resource('dynamodb',region_name =current_region)
    table = resource.Table('OrgDetails')
    result = {"org_details" : None, "request_details": None}
    response = table.get_item(Key={'id': str(accountId) } )
    if "Item" in response.keys():
        result["org_details"] = response["Item"]
        request_table = resource.Table('OrgAccountRequest')
        request_table_response = request_table.get_item(Key={'id': str(response["Item"]["email"]) } )
        if "Item" in request_table_response.keys():
            result["request_details"] = request_table_response["Item"]

    return result

def get_all_accounts(region="us-east-2"):
    session = boto3.Session()
    resource = session.resource('dynamodb',region_name = region)
    table = resource.Table('OrgDetails')
    pe = "id, accountType"
    response = table.scan(ProjectionExpression=pe)
    result = []
    for i in response['Items']:
        result.append(i)

    return result

def aws_session(role=None, session_name='my_session',source_session=None):
      """
      If role_arn is given assumes a role and returns boto3 session
      otherwise return a regular session with the current IAM user/role
      """
      current_region = os.getenv("AWS_REGION")
      print(f"Current region: {current_region}")
      if role:
          if source_session:
              client = source_session.client('sts')
          else:
              client = boto3.client('sts')
          
          response = client.assume_role(RoleArn=role, RoleSessionName=session_name)
          session = boto3.Session(
              aws_access_key_id=response['Credentials']['AccessKeyId'],
              aws_secret_access_key=response['Credentials']['SecretAccessKey'],
              aws_session_token=response['Credentials']['SessionToken'],
              region_name = current_region)
          return session
      else:
          return boto3.Session()

def get_param(parameter_name, region_name = "us-east-2"):
    """Retrieve the given AVM parameter."""
    session = boto3.Session()
    resource = session.resource('dynamodb',region_name)
    table = resource.Table('AVMConfig')

    response = table.get_item(
        Key={
        "parameter": str(parameter_name),
        }
    )
    retval = None
    if "Item" in response.keys():
        item = response['Item']
        retval = item['value']

    return retval

def send_pipeline_notification(accountId, snsARN, function_name, subject, body):
    """Push a notification to an SNS topic attached to an AWS account."""
    snsclient = boto3.client('sns')
    sub = f"AVM-{accountId}-{function_name}-{subject}"
    event = {
    "Message" : body,
    "sub": sub,
    "account" : accountId,
    "function" : function_name
    }
    snspublish = snsclient.publish(
    TopicArn=snsARN,
    Subject=sub[:99],
    Message=json.dumps({'default' : json.dumps(event)}),
    MessageStructure='json')
    print(f"sent avm-pipeline notofication: {json.dumps(event)}")

# Retrieves secrets from AWS Secrets Manager
def get_secret(secret_input,region_name="us-east-2"):
    """Retrieve a secret value from AWS, given a key and a region."""
    result = None
    secret_name = secret_input

    # Create a Secrets Manager client
    session = boto3.session.Session()
    client = session.client(
        service_name='secretsmanager',
        region_name=region_name
    )

    # In this sample we only handle the specific exceptions for the 'GetSecretValue' API.
    # See https://docs.aws.amazon.com/secretsmanager/latest/apireference/API_GetSecretValue.html
    # We rethrow the exception by default.

    try:
        get_secret_value_response = client.get_secret_value(
            SecretId=secret_name
        )
    except ClientError as e:
        print(e)
        if e.response['Error']['Code'] == 'DecryptionFailureException':
            # Secrets Manager can't decrypt the protected secret text using the provided KMS key.
            # Deal with the exception here, and/or rethrow at your discretion.
            raise e
        elif e.response['Error']['Code'] == 'InternalServiceErrorException':
            # An error occurred on the server side.
            # Deal with the exception here, and/or rethrow at your discretion.
            raise e
        elif e.response['Error']['Code'] == 'InvalidParameterException':
            # You provided an invalid value for a parameter.
            # Deal with the exception here, and/or rethrow at your discretion.
            raise e
        elif e.response['Error']['Code'] == 'InvalidRequestException':
            # You provided a parameter value that is not valid for the current state of the resource.
            # Deal with the exception here, and/or rethrow at your discretion.
            raise e
        elif e.response['Error']['Code'] == 'ResourceNotFoundException':
            # We can't find the resource that you asked for.
            # Deal with the exception here, and/or rethrow at your discretion.
            raise e
    else:
        # Decrypts secret using the associated KMS CMK.
        # Depending on whether the secret is a string or binary, one of these fields will be populated.
        if 'SecretString' in get_secret_value_response:
            result = get_secret_value_response['SecretString']
        else:
            result = base64.b64decode(
                get_secret_value_response['SecretBinary'])
    #print(result)
    return json.loads(result)

# gets primary and secondary regions
def get_regions(account_id):
    """Retrieve the primary and secondary AWS regions used by the specified account."""
    request_details = get_account_details(account_id)["request_details"]
    print(request_details)
    primary_region = request_details["primaryRegion"]
    # NOTE: The secondary region is not part of the account request table (yet).
    # Use a helper function to get the appropriate secondary region:
    return primary_region, get_secondary_region(primary_region)

def get_secondary_region(primary_region = "us-east-2"):
    """Retrieve a secondary region given a primary region.  Defaults to US (us-east-2 returns us-east-1)."""

    # Theoretically, every region has a 'desired' secondary region. For example,
    # a company office in California wants us-east-2/us-east-1, but one in
    # New York probably wants us-east-1/us-east-2.  The choices given here are for those
    # regions that contain all necessary services and an adequate number of AZs.
    # The settings here should be adjusted as more 'supported' regions of the TLZ
    # are brought online.

    primary_to_secondary_mapping = {
        "us-east-2": "us-east-1",
        "eu-west-3": "eu-west-3" # Due to HDS restrictions the same region is used for secondary
    }

    if (primary_region in primary_to_secondary_mapping):
        return primary_to_secondary_mapping[primary_region]

    # Try the reverse lookup (if not found in keys, search values for the first match).
    # This is not a *guaranteed* result due to the nature of dicts and the configuration
    # of the region mapping.  If two primary regions were mapped to the same secondary
    # region, the answer will be location-dependent.
    for rev_secondary, rev_primary in primary_to_secondary_mapping.items():
        if rev_primary == primary_region:
            return rev_secondary

    # No luck--return the most functional secondary of all.
    return "us-east-1"

def az_map_by_region(primary_region, secondary_region = None):
    """
    Generate three AZ names for each region given.
    One region is required (and will get the 'appropriate' secondary region);
    two may be provided for explicit settings.
    """
    if not secondary_region:
        secondary_region = get_secondary_region(primary_region)

    azs_primary = "[\""+primary_region+"a\", \""+primary_region+"b\", \""+primary_region+"c\"]"
    azs_secondary = "[\""+secondary_region+"a\", \""+secondary_region+"b\", \""+secondary_region+"c\"]"

    return azs_primary, azs_secondary

def resource_workspace_required(account_type):
    """Indicate whether a given account type requires a Terraform workspace for resources."""
    requires_resources_workspace = account_type.lower() in ["application", "sandbox"]
    return requires_resources_workspace

# Given a top-level (account) type and second-level (environment) type,
# return a three-character, *uppercase* code indicating the 'type' of account this is.
def get_short_account_code(account_type, environment_type):
    """Return a three-character, uppercase code indicating the account type."""

    if (account_type == "core"):
        code = "COR"
    elif (account_type == "developer"):
        code = "DEV"
    elif (account_type == "sandbox"):
        code = "SBX"
    elif (account_type == "application" and environment_type == "npd"):
        code = "NPD"
    elif (account_type == "application" and environment_type == "prd"):
        code = "PRD"
    else:
        # Default to the least privileged type:
        code = "SBX"

    return code

def get_okta_group_name(prefix, account_id, role_name):
    """
    Return an Okta group name specific to an account.
    The format of the group name is '<prefix>_<account_id>_role'.
    """
    group_name = prefix + "_" + account_id + "_" + role_name
    print(f"get_okta_group_name() result is {group_name}")
    return group_name

# Return the name of the TLZ delegated admin role for comparison purposes.
def get_delegated_admin_role():
    """Return the name of the delegated administrator role."""
    return "tlz_admin"

# Return the name of the TLZ delegated developer role for comparison purposes.
def get_delegated_developer_role():
    """Return the name of the delegated developer role."""
    return "tlz_developer"

# Return the name of the TLZ delegated read-only developer role for comparison purposes.
def get_delegated_developer_ro_role():
    """Return the name of the delegated read-only developer role."""
    return "tlz_developer_ro"

# Returns a *tuple* of TLZ delegated roles which are consumed by users.
# (Immutable types are required for some string operations, e.g. .endswith).
def get_delegated_user_managed_roles():
    """Return a tuple of AVM-generated role names managed by users."""
    return (get_delegated_admin_role(),
            get_delegated_developer_role(),
            get_delegated_developer_ro_role()
            )

# Creates Okta group name based on specified logic / naming convention
def generate_okta_group_names(account_id, account_type, environment_type, account_alias):
    """
    Create an array of Okta group names to provision for the specified account.
    The items in the array have the naming syntax 'awsxyz_123456789012_role', where 'xyz' is a
    three-character account type, '123...' is the AWS account number, and 'role' is the group identifier.
    """

    env_roles = {
        "master_payer" : ["tlz_security_operations","tlz_organization_admin","tlz_billing_admin"],
        "shared_services" : ["tlz_admin", "tlz_security_operations","tlz_it_operations"],
        "logging" : ["tlz_admin", "tlz_security_operations","tlz_it_operations","tlz_intra_network"],
        "security" : ["tlz_admin", "tlz_security_operations"],
        "network" : ["tlz_admin", "tlz_security_operations","tlz_it_operations", "tlz_intra_network","tlz_inter_network"],
        "sandbox" : ["tlz_admin", "tlz_security_operations","tlz_it_operations", "tlz_developer_ro","tlz_developer","tlz_intra_network",],
        "application_npd" : ["tlz_admin", "tlz_security_operations","tlz_it_operations", "tlz_developer_ro","tlz_developer","tlz_intra_network","tlz_inter_network"],
        "application_prd" : ["tlz_admin", "tlz_security_operations","tlz_it_operations","tlz_developer_ro", "tlz_intra_network","tlz_inter_network"]
    }
    env = account_alias

    okta_prefix = None
    if(account_type == "application"):
        env = f"application_{environment_type}"
    elif (account_type == "sandbox"):
        env = "sandbox"

    okta_prefix = "aws" + get_short_account_code(account_type, environment_type).lower()

    okta_group_names = []
    for key in env_roles:
        if key in env:
            for role in env_roles[key]:
                okta_group_names.append(get_okta_group_name(okta_prefix, account_id, role))
    return okta_group_names
